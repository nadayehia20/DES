# DES
Hexa-Decimal DES (Encryption and Decryption) 
The implemented program takes 3 inputs: the key, the message, and the number of times you want to run this encryption. It also asks you whether you want to encrypt or decrypt.
Firstly, Key generation function: the key is converted to binary, divided into two halves then an initial permutation is applied (converts from 64 bits to 56 bits). The resulted 56-bit key is then divided into two halves (left and right). A loop that loops 16 times is applied to the two halves, for loops number 1,2,9 and 16, each half of the key is shifted left by 1 bit, while in the rest of the loop numbers each half is shifted left by 2 bits. At the end of every loop the resulted half of key is saved in a list.so, at the end of the loop we have 2 lists each one has 16 elements (half of key). Then the two lists are concatenated together, then the second permutation is applied on the resulted list.
So, now we have a list of 16 keys
We’re now going to operate on the input plain text through the function enc: this function takes the input plain text and the number of required encryptions and the list of the key.
Firstly, the plaintext is converted to binary, and an initial permutation is applied on the binary plain text. Then, the resulted message is divided into two halves, the right half of the current cycle is the left half of the next cycle, the right half of the current cycle enters a separate cycle which is: expanded by the expansion table, and then XORed with the equivalent key from the key list generated by the previous function, and the result is divided to 8 parts, 6 bits each. Each part is then s-boxed (converted from 6 bits to 4 bits), and then the result is applied to a permutation again, and XORed with the left part of the current message. This cycle is repeated 16 times, the last left and right part resulted from this cycle are concatenated together, and a final permutation is applied to this concatenation. And here’s the result in binary, it’s then converted to hexa-decimal. (the function is repeated again depending on the input number of encryptions)
If it’s required to decrypt: the key list is reversed, and the 2 halves of the message are also reversed and the same encryption function is called again without any changes in its body.

